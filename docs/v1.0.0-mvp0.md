# coordinate system & reference points

this doc explains **how positions are represented**: board coordinates, piece-local coordinates, how they relate, and which point is used as the reference for movement/collision.

---

## quick summary

* **board coordinates**: `(row, col)` with origin at the **top-left** of the visible playfield. rows grow **down**, columns grow **right**.
* **piece-local coordinates**: each tetromino lives in a **4×4 local grid** with its own origin at the **top-left** of that 4×4.
* **reference point**: `piece.row`/`piece.col` is the **top-left of the piece’s 4×4** expressed in **board coordinates**.
* **overlay formula**: a filled local cell `(r, c)` maps to board cell `(br, bc)` using:

  ```c
  br = piece.row + r;
  bc = piece.col + c;
  ```

---

## board coordinates

* dimensions: `H × W` (defaults: `H = 20`, `W = 10`).
* valid indices: `row ∈ [0, fdH-1]`, `col ∈ [0, W-1]`.
* storage: `board[row][col]` where `0 = empty`, `> 0 = filled (piece id/color)`.

**axis orientation**

```
(row)
  0  →  (0,0) (0,1) (0,2) ... (0,9)
  1  →  (1,0) (1,1) (1,2) ... (1,9)
  2  →  (2,0) (2,1) (2,2) ... (2,9)
  ⋮
 19  → (19,0) ………………………… (19,9)
         ↑ col=0            → col increases →
```

**bounds helpers**

* `board_in_bounds(r,c)`: `true` iff `0 ≤ r < H` and `0 ≤ c < W`.
* `board_cell(r,c)`: returns `-1` if OOB, else the cell value.

> **note:** only the **active falling piece** is allowed to have negative rows (spawning above the board). The **board array** itself is never indexed with negative numbers.

---

## piece local coordinates (4×4)

every tetromino is represented in a **4×4 local grid**. local indices are always `r ∈ [0,3]`, `c ∈ [0,3]`. The local origin is the **top-left of that 4×4**.

for mvp0 we only have the **I-piece** with a horizontal line on local row `1`:

```
local r\c:   0 1 2 3
           ┌─────────┐
        0  │ . . . . │
        1  │ X X X X │  ← filled cells
        2  │ . . . . │
        3  │ . . . . │
           └─────────┘
```

here, `shape_at(r,c)` returns `1` exactly when `r == 1 && 0 ≤ c ≤ 3`.

---

## reference point (anchor) on the board

* `piece.row` / `piece.col` identifies the **top-left of the piece’s 4×4** in **board coordinates**.
* during **spawn**, `piece.row` can be **negative** so the piece starts partially above the visible board (e.g., `row = -2`).
* Typical spawn for a 4-wide I-piece:

  ```c
  piece.row = -2;                  // slightly above the board
  piece.col = (W / 2) - 2;         // centers a 4-wide piece in W=10 → 3
  ```

**overlay rule** (repeat for each local filled cell):

```c
int br = piece.row + r;  // board row
int bc = piece.col + c;  // board col
```

* if `br < 0`, the cell is **above the top** and is **not** checked for occupancy.
* otherwise, require `0 ≤ bc < W`, `0 ≤ br < H`, and `board[br][bc] == 0` to place.

---

## movement & gravity in coordinates

* **left**: `piece.col -= 1` (only if placement remains valid).
* **right**: `piece.col += 1`.
* **down** (gravity/soft drop): `piece.row += 1`.
* **lock**: when moving down is blocked, copy every filled local cell `(r,c)` to `board[br][bc]` (for `br ≥ 0`).

---

## worked example

assume `W=10`, `H=20`, and an I-piece spawned at:

```
piece.row = -2
piece.col =  3         // (W/2)-2 = 3 when W=10
```

local filled cells are `(1,0..3)`. Mapped to the board:

1. **at spawn** (`row = -2`):

   * `br = -2 + 1 = -1` (above board), `bc = 3..6`. All are **above** the top → allowed.

2. **after 2 steps down** (`row = 0`):

   * `br = 0 + 1 = 1`, `bc = 3..6` → occupy board cells `(1,3)–(1,6)`.

3. **attempt to move left** to `col = 2`:

   * check `(1,0..3)` → map to `(1,2..5)`. If all in-bounds and empty, move is allowed.

if the next **down** step would put any filled cell at `br == H` or on an occupied cell, the piece **locks** at the current position and its blocks are written into `board`.

---

## rendering note (ncurses)

ncurses uses `(y, x)` where **`y` is row** and **`x` is column**. To draw a cell as two characters wide (for a 10×20 board with nicer proportions):

```c
int y = br + 1;         // optional margin
int x = bc * 2 + 2;     // 2 chars per cell + left margin
mvprintw(y, x, filled ? "[]" : " .");
```

---

## future rotation (not in MVP0)

* Keep using the same reference point: **top-left of the 4×4** in board space.
* Rotation changes which `(r,c)` are filled in the 4×4. With SRS, you’ll also try small **kick** offsets `(Δrow, Δcol)` if a rotated shape collides; the reference point itself remains `piece.row/col` with temporary offsets during tests.
